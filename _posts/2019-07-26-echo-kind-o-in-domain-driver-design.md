---
layout: post
title: "在领域驱动设计中的各种 O"
date: "2019-07-26"
description: "在领域驱动设计中的各种 O"
tag: [java]
---

### 在领域驱动设计中的各种 O
- RO (Request Object)
请求对象, 用于封装前端页面请求参数 (当请求参数大于三个时建议封装)
- VO (View Object)
视图对象, 用于展示层, 它的作用是把某个前端页面 (或组件) 的所有数据封装起来
- DTO (Data Transfer Object)
数据传输对象, 原本的目的是为了 EJB 的分布式应用提供粗粒度的数据实体, 以减少分布式调用的次数, 从而提高分布式调用的性能和降低网络负载; 现在泛指用于控制层与服务层之间的数据传输对象
- DO (Domain Object)
领域对象, 就是从现实世界中抽象出来的业务实体
- PO (Persistent Object)
持久化对象, 它与持久层 (通常是关系型数据库) 的数据结构形成一对一的映射关系; 如果持久层是关系型数据库, 那么数据表中的每个 (或若干个) 字段就对应 PO 的一个 (或若干个) 属性
- BO (Business Object)
业务对象, 包括了业务逻辑, 常常封装了对 DAO, RPC 的调用; 提供基本业务单元的基本业务操作, 这是区别与直接对外提供服务的 Service 的一点
- DAO (Data Access Object)
数据访问对象, 使用 DAO 访问数据库, 完成对数据库操作的封装
- POJO ( Plain Ordinary Java Object)
表示一个简单的 Java 对象, 主要用于封装数据, 以上所叙述的 RO, VO, DTO, DO, PO 都属于 POJO; 而 BO, DAO 则不属于 POJO, 而是功能对象的范围

#### 以上各种 O 存在时使用的应用分层
```
        RO               DTO           DO       PO  
static <===> controller <===> service <===> bo <===> dao
        VO               DTO           DO       PO
```

#### VO 与 DTO 的区别
- 首先在概念上, 而 VO 代表展示层需要显示的数据, DTO 代表服务层需要接收的数据和返回的数据
- 以上一点只是概念上的区别, 在实际应用中, VO 和 DTO 绝大部分场景下字段是一致的, 没有必要多此一举; 但是在设计层面上应该要区分这一点, 考虑以下场景
  - 有一个性别 (gender) 的属性, 在 DTO 中使用了 1 表示男性, 2 表示女性, 0 表示未知, 在展示层可能需要用 "帅哥" 表示男性, "美女" 表示女性, "秘密" 表示未知; 这里可能有人会想直接在 DTO 中返回 "帅哥", "美女", "秘密" 不就可以了吗? 其实对于大多数应用来说是可以的, 但是考虑下面一点
  - 如果需求允许客户制定风格, 不同风格对 "性别" 的表现形式不一样; 如果直接在 DTO 中返回 "帅哥", "美女", "秘密", 那么问题就来了; 回到设计层面上, 从职责单一原则来看, 服务层只负责业务, 与具体的表现形式无关, 因此返回的 DTO, 不应该出现于表现层的耦合
#### VO 与 DTO 的应用
上一节主要叙述了 VO 与 DTO 的区别, 但实际应用中, 如果能把 VO 和 DTO 合二为一, 那么应该可以省去不少代码量; 以下场景可以考虑将其合二为一
- 需求非常清晰稳定, 不经常做改动; 那么没有太多必要把 VO 和 DTO 区分开啦, 可以将 VO 隐退, 只是用 DTO; DTO 这时仍然只对业务层负责, 性别字段仍然用 "0, 1, 2" 表示, "帅哥, 美女, 秘密" 的转换可以依赖于前端 JS 脚本

#### DTO 与 DO 的区别
- 首先在概念上, DTO 是展示层和服务层之间的数据传输对象 (可以认为是两者之间的协议), 而 DO 是对现实世界中业务实体的抽象
- 在实际应用中, 例如 UserDTO 和 UserDO, 对于服务层的 getUser 方法来说, 返回的数据不应该包括用户的 password, 所以逻辑上 UserDTO 应该比 UserDO 少一个 password 字段

#### DTO 与 DO 的应用
在上一节叙述中其实有一个 BUG, 就是如果 UserDTO 没有 password 字段, 那么在 createUser 方法时, UserDTO 传入 password?
- 在设计层面, 展示层向服务层传递的 DTO 和服务层返回给展示层的 DTO 在概念上是不同的, 但在实现层面上很少这样去做 (定义多个 UserDTO); 这里在实际应用时是设计一个兼容的 DTO, 服务层接收数据的时候, 不该由展示层设置的属性无论展示层是否设置, 服务层都应该忽略, 而在服务层返回数据时, 不该返回的数据不应设置属性值
- 这里为什么不在服务层中直接返回 DO, 以省去 DTO 的编码和转换工作, 有以下原因
  - DTO 和 DO 本质上不是一一对应的, 一个 DTO 可能对应多个 DO, 一个 DO 也可能对应多个 DTO, 两者甚至可以是多对多的关系
  - DO 是领域对象, 包含了具体的业务信息, 有一些不应该展示层知道的数据
  - 从设计层面来说, 展示层依赖于服务层, 服务层依赖于领域层, 如果把 DO 直接暴露到展示层, 这种跨层的依赖会导致不必要的耦合

#### DO 与 PO 的区别
DO 与 PO 在绝大多数情况下是一一对应的, 但有一些场景还是能反应出来两者在概念上本质的区别
- 关系型数据库中, 多对多产生的中间表有的在业务领域没有任何意义, 完全不能与任何 DO 相对应; 例如老师和学生之间的多对多关系, 但有些多对多关系是有业务意义的, 例如角色与资源之间的多对多关系, 这种关系表现为一个 DO (权限)
- 在某些情况下, 为了持久化策略或者性能考虑, 一个 PO 可能对应多个 DO, 反之亦然
- 存在 PO 中的某些字段对于 DO 没有任何意义, 或者存在不需要将 DO 的某些字段值持久化的情况, 那么也不会是完全对应的

#### DO 与 PO 的应用
由于 ORM 框架的流行和 JPA 规范的推出, 现在的业务应用开发基本上不再需要区分 DO 与 PO, PO 完全可以通过 JPA 的一些注解隐藏在 DO 之中

#### 优化命名以及分层
上述各种 O 有时为 POJO, 有时又为分层名, 为了更加可读优化命名增加区分度
```
        RO               DTO           DO             PO  
static <===> controller <===> service <===> business <===> repository
        VO               DTO           DO             PO
```
业务逻辑复杂度不高的应用可以省略 business 层
```
        RO               DTO           PO  
static <===> controller <===> service <===> repository
        VO               DTO           PO
```
这里的 RO 和 VO 可以兼容为同一个 O, 利用 swagger 的注解标注请求时字段是否必须

>**参考:**  
[VO、DTO、DO、PO 我告诉你](https://cloud.tencent.com/developer/article/1062270)
[浅析VO、DTO、DO、PO的概念、区别和用处](http://www.blogjava.net/johnnylzb/archive/2010/05/27/321968.html)  
[实体类（VO，DO，DTO，PO）的划分](https://blog.csdn.net/u010722643/article/details/61201899)  
[java对象：PO/POJO/VO/BO/DAO/DTO分析](https://zhuanlan.zhihu.com/p/42288383)
