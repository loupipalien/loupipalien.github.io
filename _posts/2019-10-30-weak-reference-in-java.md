---
layout: post
title: "Java 中的弱引用"
date: "2019-10-30"
description: "Java 中的弱引用"
tag: [java]
---

### Java 中的弱引用

#### 弱引用是什么
Java 中的弱引用是指 `java.lang.ref.WeakReference<T>` 类, 官方文档如下  
```
弱引用对象, 不能避免它们的引用被标记为可终结的, 被终结, 以及被回收; 弱引用对象常常用于实现规范化映射  
假定垃圾回收器在某一个时间点确定一个对象是弱可达的 (weakly reachable); 届时它会自动清除这个对象的所有弱引用,　以及从这个对象通过强引用或者弱引用可达的弱可达对象的所有弱引用; 与此同时它将会声明所有的之前弱可达的对象是可终结的; 同时或稍后它将这些新清理的弱引用入队到这些弱引用注册的引用队列中
```

##### 引用类型
在 Java 中有在四种引用, 由强到弱依次是: 强引用, 软引用, 弱引用, 虚引用
- 强引用 (Strong Reference): 代码中普遍存在的, 类似 `Object obj = new Object()` 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用 (Soft Reference): 用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收
- 弱引用 (Weak Reference): 用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象
- 虚引用 (Phantom Reference): 也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

##### 可达类型
出四种引用之外, 还有四种可达性, 不同等级的可达性反应了对象的声明周期; 由强到弱依次是: 强可达的, 软可达的, 弱可达的, 虚可达的
- 强可达的: 如果一个对象不用线程遍历引用对象就可到达, 那这个对象就是强可达的; 线程中通过新创建的对象都是强可达的
- 软可达的: 如果一个对象不是强可达的, 但是可以通过遍历软引用可到达, 那这个对象就是软可达的
- 弱可达的: 如果一个对象不是强可达或软可达的, 但是可以通过遍历弱引用可到达, 那这个对象就是软可达的; 当指向软可达对象的软引用被清理, 这个对象就是可终结的
- 虚可达的: 如果一个对象不是强可达或软可达或弱可达的, 但是有一些虚引用指向它, 这个对象会被终结

当一个对象不能通过以上任意一个方式到达, 则是不可达的, 这个对象就是可回收的

#### 使用场景
```Java
Object obj = new Object();
WeakReference<Object> weakReference = new WeakReference<>(obj);
// 当有强引用存在时, 通过弱引用获取
obj = weakReference.get();
// 当强引用不存在时, 弱可达对象的所有弱引用会被清除
obj = null; // weakReference.get() 也将会返回 null
```
实际的使用场景, 见 `ThreadLocal.ThreadLocalMap` 类

>**参考:**
- [Class WeakReference<T> & Package java.lang.ref](https://docs.oracle.com/javase/8/docs/api/)
- [理解Java中的弱引用](https://www.cnblogs.com/absfree/p/5555687.html)
